name: Install Zune
description: Installs the given Zune version or build artifact
inputs:
  version:
    description: Specific version
    default: latest
    required: false
  artifact:
    description: Specific build artifact
    required: false
  token:
    description: Github token
    required: true
runs:
  using: composite
  steps:
    - name: Download and Install
      shell: bash
      run: |
        PROGRAM_NAME="zune"
        BINARY_NAME="$PROGRAM_NAME"
        REPOSITORY="Scythe-Technology/Zune"

        if [[ ! -z "${{ inputs.artifact }}" ]]; then
            echo "Downloading Zune via artifacts"

            curl --proto '=https' --tlsv1.2 -sSf -L -H "Authorization: token ${{ inputs.token }}" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/$REPOSITORY/actions/artifacts/${{ inputs.artifact }}/zip" -o zune.zip
            unzip -o -q "zune.zip" "$BINARY_NAME" -d .
            rm zune.zip
        else
            echo "Downloading Zune via releases"

            # Largely based on https://raw.githubusercontent.com/rojo-rbx/rokit/main/scripts/install.sh
            # Copyright (c) 2024

            # Permission is hereby granted, free of charge, to any person obtaining a copy
            # of this software and associated documentation files (the "Software"), to deal
            # in the Software without restriction, including without limitation the rights
            # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            # copies of the Software, and to permit persons to whom the Software is
            # furnished to do so, subject to the following conditions:

            # The above copyright notice and this permission notice shall be included in all
            # copies or substantial portions of the Software.

            # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            # SOFTWARE.

            set -eo pipefail

            # Make sure we have all the necessary commands available
            dependencies=(
                curl
                unzip
                uname
                tr
            )

            for dep in "${dependencies[@]}"; do
                if ! command -v "$dep" >/dev/null 2>&1; then
                    echo "ERROR: '$dep' is not installed or available." >&2
                    exit 1
                fi
            done

            # Determine OS and architecture for the current system
            OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
            case "$OS" in
                darwin) OS="macos" ;;
                linux) OS="linux" ;;
                cygwin*|mingw*|msys*) OS="windows" ;;
                *)
                    echo "Unsupported OS: $OS" >&2
                    exit 1 ;;
            esac
            ARCH="$(uname -m)"
            case "$ARCH" in
                x86_64) ARCH="x86_64" ;;
                x86-64) ARCH="x86_64" ;;
                arm64) ARCH="aarch64" ;;
                aarch64) ARCH="aarch64" ;;
                *)
                    echo "Unsupported architecture: $ARCH" >&2;
                    exit 1 ;;
            esac

            # Construct file pattern for our desired zip file based on OS + arch
            # NOTE: This only works for exact patterns "binary-X.Y.Z-os-arch.zip"
            # and WILL break if the version contains extra metadata / pre-release
            VERSION_PATTERN="[0-9]*\\.[0-9]*\\.[0-9]*"
            API_URL="https://api.github.com/repos/$REPOSITORY/releases/latest"
            if [ ! -z "$1" ]; then
                # Fetch a specific version from given script argument
                VERSION_PATTERN="$1"
                API_URL="https://api.github.com/repos/$REPOSITORY/releases/tags/v$1"
                printf "\n[1 / 3] Looking for $PROGRAM_NAME release with tag 'v$1'\n"
            else
                # Fetch the latest release from the GitHub API
                printf "\n[1 / 3] Looking for latest $PROGRAM_NAME release\n"
            fi
            FILE_PATTERN="${PROGRAM_NAME}-${VERSION_PATTERN}-${OS}-${ARCH}.zip"

            # Use curl to fetch the latest release data from GitHub API
            RELEASE_JSON_DATA=$(curl --proto '=https' --tlsv1.2 -sSf "$API_URL" \
              -H "X-GitHub-Api-Version: 2022-11-28" -H "Authorization: token ${{ inputs.token }}")

            # Check if the release was fetched successfully
            if [ -z "$RELEASE_JSON_DATA" ] || [[ "$RELEASE_JSON_DATA" == *"Not Found"* ]]; then
                echo "ERROR: Latest release was not found. Please check your network connection." >&2
                exit 1
            fi

            # Try to extract the asset url from the response by searching for a
            # matching asset name, and then picking the "url" that came before it
            RELEASE_ASSET_ID=""
            RELEASE_ASSET_NAME=""
            while IFS= read -r current_line; do
                if [[ "$current_line" == *'"url":'* && "$current_line" == *"https://api.github.com/repos/$REPOSITORY/releases/assets/"* ]]; then
                    RELEASE_ASSET_ID="${current_line##*/releases/assets/}"
                    RELEASE_ASSET_ID="${RELEASE_ASSET_ID%%\"*}"
                elif [[ "$current_line" == *'"name":'* ]]; then
                    current_name="${current_line#*: \"}"
                    current_name="${current_name%%\"*}"
                    if [[ "$current_name" =~ $FILE_PATTERN ]]; then
                        if [ -n "$RELEASE_ASSET_ID" ]; then
                            RELEASE_ASSET_ID="$RELEASE_ASSET_ID"
                            RELEASE_ASSET_NAME="$current_name"
                            break
                        else
                            RELEASE_ASSET_ID=""
                        fi
                    else
                        RELEASE_ASSET_ID=""
                    fi
                fi
            done <<< "$RELEASE_JSON_DATA"

            if [ -z "$RELEASE_ASSET_ID" ] || [ -z "$RELEASE_ASSET_NAME" ]; then
                echo "ERROR: Failed to find asset that matches the pattern \"$FILE_PATTERN\" in the latest release." >&2
                exit 1
            fi

            # Download the file using curl and make sure it was successful
            echo "[2 / 3] Downloading '$RELEASE_ASSET_NAME'"
            RELEASE_DOWNLOAD_URL="https://api.github.com/repos/$REPOSITORY/releases/assets/$RELEASE_ASSET_ID"
            ZIP_FILE="${RELEASE_ASSET_NAME%.*}.zip"
            curl --proto '=https' --tlsv1.2 -L -o "$ZIP_FILE" -sSf "$RELEASE_DOWNLOAD_URL" \
              -H "X-GitHub-Api-Version: 2022-11-28" -H "Accept: application/octet-stream"  -H "Authorization: token ${{ inputs.token }}"
            if [ ! -f "$ZIP_FILE" ]; then
                echo "ERROR: Failed to download the release archive '$ZIP_FILE'." >&2
                exit 1
            fi

            # Unzip only the specific file we want and make sure it was successful
            if [ "$OS" = "windows" ]; then
                BINARY_NAME="${BINARY_NAME}.exe"
            fi
            unzip -o -q "$ZIP_FILE" "$BINARY_NAME" -d .
            rm "$ZIP_FILE"
        fi

        if [ ! -f "$BINARY_NAME" ]; then
            echo "ERROR: The file '$BINARY_NAME' does not exist in the downloaded archive." >&2
            exit 1
        fi

        chmod +x "$BINARY_NAME"
        mkdir zune_bin
        mv "$BINARY_NAME" zune_bin/
        echo "$GITHUB_WORKSPACE/zune_bin" >> $GITHUB_PATH

        echo "Installed Zune"
